#!/usr/bin/env python3
"""
setup_tui.py — ResearchClaw interactive setup wizard.

Usage:
    python setup_tui.py

Guides you through configuring ResearchClaw interactively, then writes:
  - config.yaml  (non-secret configuration)
  - .env         (secrets: bot tokens, API keys — chmod 600)
  - .gitignore   (ensures .env is never committed, if file does not exist)

After setup, run:
    python -m researchclaw.init <base_dir>/config.yaml
to validate the configuration and test connections.

Dependencies:  questionary  rich
    pip install questionary rich
"""

from __future__ import annotations

import os
import shutil
import stat
import subprocess
import sys
from pathlib import Path
from typing import Any

# ── Dependency checks ─────────────────────────────────────────────────────────

def _check_deps() -> None:
    missing = []
    try:
        import questionary  # noqa: F401
    except ImportError:
        missing.append("questionary")
    try:
        from rich.console import Console  # noqa: F401
    except ImportError:
        missing.append("rich")
    if missing:
        print(
            f"Missing dependencies: {', '.join(missing)}\n"
            f"Install with:  pip install {' '.join(missing)}",
            file=sys.stderr,
        )
        sys.exit(1)

_check_deps()

import questionary
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich import box

console = Console()


# ── Helpers ───────────────────────────────────────────────────────────────────

def _banner() -> None:
    console.print(Panel.fit(
        "[bold cyan]ResearchClaw Setup Wizard[/bold cyan]\n"
        "[dim]Configures the agent and writes config files to your base directory.[/dim]",
        border_style="cyan",
        padding=(1, 4),
    ))
    console.print()


def _step(n: int, total: int, title: str) -> None:
    console.print(f"[bold white]Step {n}/{total}: {title}[/bold white]")
    console.print()


def _validate_abs_path(text: str) -> bool | str:
    if not text.strip():
        return "Path cannot be empty."
    if not text.startswith("/"):
        return "Must be an absolute path starting with /."
    return True


def _validate_nonempty(text: str) -> bool | str:
    return True if text.strip() else "This field cannot be empty."


def _test_claude_cli(cli_path: str) -> tuple[bool, str]:
    try:
        r = subprocess.run([cli_path, "--version"], capture_output=True, text=True, timeout=10)
        if r.returncode == 0:
            return True, r.stdout.strip()
        return False, f"exit code {r.returncode}"
    except FileNotFoundError:
        return False, f"{cli_path!r} not found in PATH"
    except subprocess.TimeoutExpired:
        return False, "timed out"


def _write_config(base_dir: str, values: dict[str, Any]) -> Path:
    """Write config.yaml (non-secret fields only)."""
    messenger_type = values["messenger_type"]
    llm_provider = values["llm_provider"]

    lines = [
        "# ResearchClaw Configuration — generated by setup_tui.py",
        "# Secrets are in .env (gitignored).",
        "",
        f'project_name: "{values["project_name"]}"',
        f'base_dir: "{base_dir}"',
        f'github_remote: "{values["github_remote"]}"',
        f'github_branch: "{values["github_branch"]}"',
        "",
        "messenger:",
        f'  type: {messenger_type}',
    ]

    if messenger_type == "telegram":
        lines += [
            f'  telegram_chat_id: "{values["telegram_chat_id"]}"',
            f'  telegram_bot_token_env: "TELEGRAM_BOT_TOKEN"',
            "  telegram_poll_timeout: 30",
            "  telegram_poll_interval: 1.0",
        ]
    elif messenger_type == "slack":
        lines += [
            f'  slack_channel: "{values["slack_channel"]}"',
            '  slack_bot_token_env: "SLACK_BOT_TOKEN"',
            '  slack_app_token_env: "SLACK_APP_TOKEN"',
        ]

    lines += [
        "",
        "llm:",
        f'  provider: {llm_provider}',
        f'  model: "{values["llm_model"]}"',
    ]
    if llm_provider == "claude_cli":
        lines.append(f'  cli_path: "{values["claude_cli_path"]}"')
    elif llm_provider == "anthropic":
        lines.append('  api_key_env: "ANTHROPIC_API_KEY"')

    lines += [
        "",
        "env:",
        f'  backend: {values.get("env_backend", "venv")}',
        "",
        "watcher:",
        "  poll_interval: 10",
        "  status_update_interval: 7200",
        "  heartbeat_timeout: 300",
        "  gpu_idle_threshold: 60",
        "",
        "sandbox:",
        "  copy_ignore_patterns:",
        '    - ".git"',
        '    - "__pycache__"',
        '    - "*.pyc"',
        '    - "wandb"',
        '    - "outputs"',
        '    - "checkpoints"',
        '    - "*.pt"',
        '    - "*.ckpt"',
        '    - "*.safetensors"',
        '    - "*.bin"',
        '    - "node_modules"',
        "  auto_continue_sequential: true",
        "",
        "runner:",
        "  default_env: \"\"",
        "  venv_path: \"\"",
        "  always_confirm: true",
        "",
        "report:",
        "  include_diff: true",
        "  include_log_tail: 50",
        "  include_gpu_info: true",
    ]

    config_path = Path(base_dir) / "config.yaml"
    config_path.write_text("\n".join(lines) + "\n")
    return config_path


def _write_env(base_dir: str, values: dict[str, Any]) -> Path:
    """Write .env (secrets only) with mode 600."""
    env_path = Path(base_dir) / ".env"
    lines = ["# ResearchClaw secrets — generated by setup_tui.py", "# Never commit this file.", ""]

    if values.get("telegram_bot_token"):
        lines.append(f'TELEGRAM_BOT_TOKEN={values["telegram_bot_token"]}')
    if values.get("slack_bot_token"):
        lines.append(f'SLACK_BOT_TOKEN={values["slack_bot_token"]}')
    if values.get("slack_app_token"):
        lines.append(f'SLACK_APP_TOKEN={values["slack_app_token"]}')
    if values.get("anthropic_api_key"):
        lines.append(f'ANTHROPIC_API_KEY={values["anthropic_api_key"]}')

    env_path.write_text("\n".join(lines) + "\n")
    env_path.chmod(stat.S_IRUSR | stat.S_IWUSR)  # 600
    return env_path


def _ensure_gitignore(base_dir: str) -> None:
    """Add .env to .gitignore if .gitignore exists and doesn't already mention it."""
    gi = Path(base_dir) / ".gitignore"
    if gi.exists():
        content = gi.read_text()
        if ".env" not in content:
            gi.write_text(content + "\n# Secrets\n.env\n")
    else:
        gi.write_text("# Secrets\n.env\n")


def _review_table(values: dict[str, Any]) -> None:
    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 1))
    table.add_column("Key", style="dim", no_wrap=True)
    table.add_column("Value")

    def row(key: str, val: str, secret: bool = False) -> None:
        table.add_row(key, "[dim]****[/dim]" if secret else val)

    row("Project name", values["project_name"])
    row("Base directory", values["base_dir"])
    row("GitHub remote/branch", f'{values["github_remote"]} / {values["github_branch"]}')
    row("Messenger", values["messenger_type"])

    if values["messenger_type"] == "telegram":
        row("  Telegram chat_id", values.get("telegram_chat_id", ""))
        row("  Telegram bot token", "", secret=True)
    elif values["messenger_type"] == "slack":
        row("  Slack channel", values.get("slack_channel", ""))
        row("  Slack bot token", "", secret=True)
        row("  Slack app token", "", secret=True)

    row("Env backend", values.get("env_backend", "venv"))
    row("LLM provider", values["llm_provider"])
    row("LLM model", values["llm_model"])
    if values["llm_provider"] == "anthropic":
        row("  Anthropic API key", "", secret=True)
    if values["llm_provider"] == "claude_cli":
        row("  Claude CLI path", values["claude_cli_path"])

    console.print(table)


# ── Wizard steps ──────────────────────────────────────────────────────────────

def _step1_project(values: dict[str, Any]) -> None:
    _step(1, 6, "Project")

    values["project_name"] = questionary.text(
        "Project name:",
        default="my-research-project",
        validate=_validate_nonempty,
    ).ask()
    if values["project_name"] is None:
        sys.exit(0)

    values["base_dir"] = questionary.text(
        "Base directory (absolute path on this machine):",
        default=str(Path.home() / "Main"),
        validate=_validate_abs_path,
    ).ask()
    if values["base_dir"] is None:
        sys.exit(0)

    values["github_remote"] = questionary.text(
        "GitHub remote name:", default="origin"
    ).ask() or "origin"

    values["github_branch"] = questionary.text(
        "GitHub branch:", default="main"
    ).ask() or "main"

    console.print()


def _step2_messenger(values: dict[str, Any]) -> None:
    _step(2, 6, "Messenger")

    choice = questionary.select(
        "How should ResearchClaw communicate with you?",
        choices=[
            questionary.Choice("Telegram  (bot — recommended for VM deployments)", value="telegram"),
            questionary.Choice("Slack     (native Socket Mode — no public IP needed)", value="slack"),
            questionary.Choice("Stdio     (stdin/stdout — local development only)", value="stdio"),
        ],
    ).ask()
    if choice is None:
        sys.exit(0)
    values["messenger_type"] = choice

    if choice == "telegram":
        # Pre-fill from onboard's Telegram discovery (env vars set by ./onboard)
        prefill_token = os.environ.get("_ONBOARD_TG_TOKEN", "")

        if prefill_token:
            console.print(
                "\n[dim]Bot token was discovered during onboarding. Press Enter to keep it,[/dim]\n"
                "[dim]or paste a different token.[/dim]\n"
            )
        else:
            console.print(
                "\n[dim]You need a Telegram bot token from @BotFather.\n"
                "If you don't have a bot yet: open Telegram, message @BotFather, and run /newbot.\n"
                "After creating the bot, send it any message so we can detect your chat ID.[/dim]\n"
            )

        values["telegram_bot_token"] = questionary.password(
            "Telegram Bot Token (from @BotFather):",
            default=prefill_token,
            validate=_validate_nonempty,
        ).ask()
        if values["telegram_bot_token"] is None:
            sys.exit(0)

        # Auto-detect chat ID from bot's recent messages
        chat_id = _telegram_detect_chat_id(values["telegram_bot_token"])

        if chat_id:
            console.print(f"[green]Detected chat ID: {chat_id}[/green]")
            values["telegram_chat_id"] = chat_id
        else:
            console.print(
                "[yellow]Could not auto-detect chat ID.[/yellow]\n"
                "[dim]Make sure you've sent at least one message to the bot, then re-run setup.\n"
                "Or paste your chat ID manually:[/dim]\n"
            )
            values["telegram_chat_id"] = questionary.text(
                "Telegram Chat ID:",
                validate=_validate_nonempty,
            ).ask()
            if values["telegram_chat_id"] is None:
                sys.exit(0)

        if questionary.confirm("Send a test message to verify the connection now?", default=True).ask():
            _telegram_test(values)

    elif choice == "slack":
        console.print(
            "\n[dim]Slack integration uses Socket Mode (outbound WebSocket — no public IP needed).\n"
            "You need a Slack App with two tokens:\n"
            "  1. Bot Token (xoxb-...) — from 'OAuth & Permissions' after installing the app\n"
            "  2. App-Level Token (xapp-...) — from 'Socket Mode' settings\n\n"
            "Required Bot Token Scopes: chat:write, channels:history, channels:read\n"
            "Required App Token Scope: connections:write\n"
            "Required Event Subscription: message.channels\n\n"
            "Create your app at: https://api.slack.com/apps[/dim]\n"
        )

        values["slack_bot_token"] = questionary.password(
            "Slack Bot Token (xoxb-...):",
            validate=_validate_nonempty,
        ).ask()
        if values["slack_bot_token"] is None:
            sys.exit(0)

        values["slack_app_token"] = questionary.password(
            "Slack App-Level Token (xapp-...):",
            validate=_validate_nonempty,
        ).ask()
        if values["slack_app_token"] is None:
            sys.exit(0)

        values["slack_channel"] = questionary.text(
            "Slack channel:", default="#research-agent"
        ).ask() or "#research-agent"

        if questionary.confirm("Send a test message to verify the Slack connection now?", default=True).ask():
            _slack_test(values)

    console.print()


def _telegram_detect_chat_id(token: str) -> str | None:
    """Fetch the bot's recent updates and return the first chat ID found."""
    try:
        import telebot
    except ImportError:
        console.print("[yellow]pyTelegramBotAPI not installed — cannot auto-detect chat ID.[/yellow]")
        return None

    with console.status("Detecting chat ID from recent messages…"):
        try:
            bot = telebot.TeleBot(token, parse_mode=None)
            updates = bot.get_updates(timeout=10)
        except Exception as exc:
            console.print(f"[red]Failed to fetch updates: {exc}[/red]")
            return None

    if not updates:
        return None

    for update in updates:
        if update.message and update.message.chat:
            return str(update.message.chat.id)

    return None


def _telegram_test(values: dict[str, Any]) -> None:
    try:
        import telebot
    except ImportError:
        console.print("[yellow]pyTelegramBotAPI not installed — skipping test.[/yellow]")
        return

    with console.status("Sending test message…"):
        try:
            bot = telebot.TeleBot(values["telegram_bot_token"], parse_mode=None)
            bot.send_message(int(values["telegram_chat_id"]), "ResearchClaw setup: connection test OK.")
            console.print("[green]Test message sent! Check your Telegram.[/green]")
        except Exception as exc:
            console.print(f"[red]Test failed: {exc}[/red]")
            console.print("[dim]Continuing anyway — you can re-run the init check later.[/dim]")


def _slack_test(values: dict[str, Any]) -> None:
    try:
        from slack_sdk import WebClient
    except ImportError:
        console.print("[yellow]slack_sdk not installed — skipping test.[/yellow]")
        return

    with console.status("Sending test message to Slack…"):
        try:
            client = WebClient(token=values["slack_bot_token"])
            # Resolve channel name to ID
            name = values["slack_channel"].lstrip("#")
            channel_id = None
            cursor = None
            while True:
                kwargs: dict[str, Any] = {"types": "public_channel,private_channel", "limit": 200}
                if cursor:
                    kwargs["cursor"] = cursor
                resp = client.conversations_list(**kwargs)
                for ch in resp["channels"]:
                    if ch["name"] == name:
                        channel_id = ch["id"]
                        break
                if channel_id:
                    break
                cursor = resp.get("response_metadata", {}).get("next_cursor")
                if not cursor:
                    break

            if not channel_id:
                console.print(f"[red]Channel '#{name}' not found. Make sure it exists and the bot is invited.[/red]")
                return

            client.chat_postMessage(channel=channel_id, text="ResearchClaw setup: connection test OK.")
            console.print("[green]Test message sent! Check your Slack channel.[/green]")
        except Exception as exc:
            console.print(f"[red]Test failed: {exc}[/red]")
            console.print("[dim]Continuing anyway — you can re-run the init check later.[/dim]")


def _step3_env(values: dict[str, Any]) -> None:
    _step(3, 6, "Experiment Environment")

    console.print(
        "[dim]ResearchClaw manages Python environments automatically.\n"
        "Each time a new package is needed, a new environment is forked\n"
        "so previous trials are not affected (copy-on-write).[/dim]\n"
    )

    choice = questionary.select(
        "Environment backend for experiments:",
        choices=[
            questionary.Choice("Python venv  (recommended — lightweight, no extra tools needed)", value="venv"),
            questionary.Choice("Conda        (if your experiments need conda-specific packages)", value="conda"),
        ],
        default="venv",
    ).ask()
    if choice is None:
        sys.exit(0)
    values["env_backend"] = choice

    if choice == "conda" and not shutil.which("conda"):
        console.print(
            "[yellow]Warning: 'conda' not found in PATH. "
            "Install Miniconda/Anaconda before starting the agent.[/yellow]"
        )

    console.print()


def _step4_llm(values: dict[str, Any]) -> None:
    _step(4, 6, "LLM Provider")

    # Auto-detect Claude CLI first — if it's available, recommend it
    cli_ok, cli_detail = _test_claude_cli("claude")

    choice = questionary.select(
        "Which LLM provider should ResearchClaw use?",
        choices=[
            questionary.Choice(
                "Claude CLI  (recommended — uses your existing `claude` login, no API key needed)"
                + (f"  [detected: {cli_detail}]" if cli_ok else ""),
                value="claude_cli",
            ),
            questionary.Choice(
                "Anthropic API  (direct SDK access — requires ANTHROPIC_API_KEY)",
                value="anthropic",
            ),
        ],
    ).ask()
    if choice is None:
        sys.exit(0)
    values["llm_provider"] = choice

    if choice == "claude_cli":
        values["claude_cli_path"] = "claude"

        if cli_ok:
            console.print(f"[green]Claude CLI detected: {cli_detail}[/green]")
        else:
            console.print(
                f"[yellow]Claude CLI not found yet: {cli_detail}[/yellow]\n"
                "[dim]Install it before starting the agent:\n"
                "  npm install -g @anthropic-ai/claude-code\n"
                "  claude login[/dim]"
            )

    elif choice == "anthropic":
        values["anthropic_api_key"] = questionary.password(
            "Anthropic API Key (sk-ant-…):",
            validate=_validate_nonempty,
        ).ask()
        if values["anthropic_api_key"] is None:
            sys.exit(0)

    # Model selection — applies to both providers
    model = questionary.select(
        "Which model?",
        choices=[
            questionary.Choice("Claude Opus 4.6    (most capable — recommended)", value="claude-opus-4-6"),
            questionary.Choice("Claude Sonnet 4.6  (balanced)", value="claude-sonnet-4-6"),
            questionary.Choice("Claude Haiku 4.5   (fastest, cheapest)", value="claude-haiku-4-5-20251001"),
        ],
        default="claude-opus-4-6",
    ).ask()
    if model is None:
        sys.exit(0)
    values["llm_model"] = model

    console.print()


def _step5_github(values: dict[str, Any]) -> None:
    # GitHub remote/branch were collected in step 1 already.
    # This step is intentionally minimal — more git options could go here.
    pass


def _step6_review_and_write(values: dict[str, Any]) -> None:
    _step(6, 6, "Review & Write")

    _review_table(values)
    console.print()

    confirmed = questionary.confirm(
        f'Write config.yaml and .env to {values["base_dir"]}?',
        default=True,
    ).ask()
    if not confirmed:
        console.print("[yellow]Aborted — no files written.[/yellow]")
        sys.exit(0)

    base_dir = values["base_dir"]
    Path(base_dir).mkdir(parents=True, exist_ok=True)

    with console.status("Creating directory structure…"):
        for name in ("github_codes", "sandbox", "experiment_reports", "core"):
            (Path(base_dir) / name).mkdir(parents=True, exist_ok=True)
        # Create envs/ under project root (experiment environments, managed by EnvManager)
        project_root = Path(__file__).resolve().parent
        (project_root / "envs").mkdir(parents=True, exist_ok=True)
        # Generate .claude/settings.json — same source of truth as init.py
        from researchclaw.init import _CLAUDE_SETTINGS
        import json as _json
        claude_dir = Path(base_dir) / ".claude"
        claude_dir.mkdir(parents=True, exist_ok=True)
        (claude_dir / "settings.json").write_text(_json.dumps(_CLAUDE_SETTINGS, indent=2) + "\n")

    console.print("[green]✓[/green] Directories and .claude/settings.json created")

    config_path = _write_config(base_dir, values)
    # Breadcrumb for ./gateway to find this config
    breadcrumb = Path(__file__).parent / ".last_config"
    breadcrumb.write_text(str(config_path) + "\n")
    console.print(f"[green]✓[/green] Wrote [bold]{config_path}[/bold]")

    env_path = _write_env(base_dir, values)
    console.print(f"[green]✓[/green] Wrote [bold]{env_path}[/bold] (chmod 600)")

    _ensure_gitignore(base_dir)
    console.print("[green]✓[/green] .env is gitignored")

    console.print()

    # Optional: run the init check now
    run_init = questionary.confirm(
        "Run `researchclaw.init` to validate the setup and test connections now?",
        default=True,
    ).ask()

    if run_init:
        console.print()
        result = subprocess.run(
            [sys.executable, "-m", "researchclaw.init", str(config_path)],
            cwd=str(Path(__file__).parent),
        )
        console.print()
        if result.returncode != 0:
            console.print(
                "[yellow]Some checks failed — fix the issues above and re-run init.[/yellow]"
            )
        else:
            console.print("[green]All checks passed![/green]")

    console.print()
    console.print(Panel.fit(
        f"[bold]Setup complete![/bold]\n\n"
        f"Start the agent:\n"
        f"  [cyan]python -m researchclaw.agent {config_path}[/cyan]\n\n"
        f"Validate / re-test anytime:\n"
        f"  [cyan]python -m researchclaw.init {config_path}[/cyan]",
        border_style="green",
        padding=(1, 2),
    ))

    if questionary.confirm("Start the agent now?", default=False).ask():
        os.execv(
            sys.executable,
            [sys.executable, "-m", "researchclaw.agent", str(config_path)],
        )


# ── Main ──────────────────────────────────────────────────────────────────────

def main() -> None:
    _banner()

    values: dict[str, Any] = {}

    _step1_project(values)
    _step2_messenger(values)
    _step3_env(values)
    _step4_llm(values)
    # step 5 (GitHub) was folded into step 1 for brevity
    _step6_review_and_write(values)


if __name__ == "__main__":
    main()
