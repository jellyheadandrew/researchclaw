"""
init.py — ResearchClaw initializer / validator CLI.

Usage:
    python -m researchclaw.init <config_path> [--json]

What it does:
  1. Loads config.yaml and .env
  2. Creates the required directory structure under base_dir
  3. Validates external dependencies (git, claude binary, nvidia-smi)
  4. Tests the configured messenger (sends a test message)
  5. Tests the LLM provider with a trivial completion
  6. Reports results to stdout

Exit codes:
  0  — all checks passed
  1  — one or more checks failed

JSON output (--json flag):
  {"success": true|false, "checks": {"<name>": "ok — detail" | "ERROR: ..."}}

This is the integration point for the web backend.  After writing config.yaml
and .env to the VM, the backend runs this command (e.g. via SSH) and parses
the JSON output to show the user a setup status report.
"""

from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path

# ── Claude agent settings — generated into {base_dir}/.claude/settings.json ──
#
# This is the single source of truth.  init.py writes it at provisioning time
# so the web backend never has to touch it manually.
#
_CLAUDE_SETTINGS: dict = {
    "description": (
        "Claude agent permission settings for ResearchClaw. "
        "Restricts tool access on top of PathValidator. "
        "Generated by researchclaw.init — do not edit manually."
    ),
    "permissions": {
        "allow": [
            "Read", "Glob", "Grep",
            "Bash(ls:*)", "Bash(cat:*)", "Bash(head:*)", "Bash(tail:*)",
            "Bash(diff:*)",
            "Bash(python:*)", "Bash(python3:*)",
            "Bash(pip:*)", "Bash(pip3:*)", "Bash(conda:*)",
            "Bash(git status:*)", "Bash(git log:*)",
            "Bash(git diff:*)", "Bash(git branch:*)",
            "Bash(nvidia-smi:*)", "Bash(ps:*)",
        ],
        "deny": [
            # All mutative git operations — go through GitManager only
            "Bash(git pull:*)", "Bash(git push:*)",
            "Bash(git commit:*)", "Bash(git add:*)",
            "Bash(git merge:*)", "Bash(git rebase:*)",
            "Bash(git reset:*)", "Bash(git checkout:*)",
            "Bash(git restore:*)", "Bash(git switch:*)",
            "Bash(git fetch:*)", "Bash(git stash:*)",
            "Bash(git rm:*)", "Bash(git mv:*)",
            "Bash(git tag:*)", "Bash(git clean:*)",
            # Destructive / network / privilege-escalation commands
            "Bash(rm -rf:*)", "Bash(sudo:*)",
            "Bash(chmod:*)", "Bash(chown:*)",
            "Bash(curl:*)", "Bash(wget:*)",
            "Bash(ssh:*)", "Bash(scp:*)",
            "Bash(kill:*)",
            # File write tools — writes go through PathValidator
            "Write", "Edit",
        ],
    },
    "notes": [
        "Write/Edit denied — file writes go through PathValidator (access_control.py).",
        "python/python3 allowed; runner cwd is always sandbox/ so relative paths land there.",
        "python -c is allowed with a warning logged; shell output paths are still validated.",
        "Mutative git ops denied here AND enforced in PathValidator._check_git_scope().",
    ],
}


def _write_claude_settings(base_dir: str) -> str:
    """
    Write .claude/settings.json into base_dir.

    This is called automatically during provisioning so the web backend never
    has to manage this file — it is always generated fresh from the
    _CLAUDE_SETTINGS constant defined in this module.

    Returns a status string for the checks report.
    """
    claude_dir = Path(base_dir) / ".claude"
    claude_dir.mkdir(parents=True, exist_ok=True)
    settings_path = claude_dir / "settings.json"
    settings_path.write_text(json.dumps(_CLAUDE_SETTINGS, indent=2) + "\n")
    return f"ok — wrote {settings_path}"


def _check_directories(base_dir: str) -> str:
    """Create expected subdirectories.  Returns status string."""
    base = Path(base_dir)
    created = []
    for name in ("github_codes", "sandbox", "experiment_reports", "reference", "core"):
        d = base / name
        if not d.exists():
            d.mkdir(parents=True)
            created.append(name)
    memory_path = base / "MEMORY.md"
    if not memory_path.exists():
        memory_path.write_text("# Agent Memory\n\n(No memories yet.)\n")
        created.append("MEMORY.md")
    summary_path = base / "RESEARCH_TRIAL_SUMMARY.md"
    if not summary_path.exists():
        summary_path.write_text(
            "# Research Trial Summary\n\n"
            "Last updated: (none)\n\n"
            "## Trial History\n\n"
            "(No trials yet.)\n"
        )
        created.append("RESEARCH_TRIAL_SUMMARY.md")
    if created:
        return f"ok — created: {', '.join(created)}"
    return "ok — all directories already exist"


def _check_git() -> str:
    try:
        result = subprocess.run(
            ["git", "--version"], capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            return f"ok — {result.stdout.strip()}"
        return f"ERROR: git returned exit {result.returncode}"
    except FileNotFoundError:
        return "ERROR: git not found in PATH"
    except subprocess.TimeoutExpired:
        return "ERROR: git --version timed out"


def _check_claude_cli(cli_path: str) -> str:
    try:
        result = subprocess.run(
            [cli_path, "--version"], capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            return f"ok — {result.stdout.strip()}"
        return f"ERROR: {cli_path!r} returned exit {result.returncode}"
    except FileNotFoundError:
        return f"ERROR: {cli_path!r} not found in PATH — run `npm install -g @anthropic-ai/claude-code` and log in"
    except subprocess.TimeoutExpired:
        return f"ERROR: {cli_path!r} --version timed out"


def _check_nvidia_smi() -> str:
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name", "--format=csv,noheader"],
            capture_output=True, text=True, timeout=10,
        )
        if result.returncode == 0:
            gpus = result.stdout.strip().splitlines()
            return f"ok — {len(gpus)} GPU(s): {', '.join(gpus)}"
        return "not available (CPU-only mode)"
    except FileNotFoundError:
        return "not available (CPU-only mode)"
    except subprocess.TimeoutExpired:
        return "ERROR: nvidia-smi timed out"


def _check_messenger(config) -> str:
    """Instantiate the messenger and send a test message."""
    try:
        from .messenger import get_messenger
        m = get_messenger(config)
        m.send(
            "ResearchClaw initializer: connection test successful. "
            "You can ignore this message."
        )
        return f"ok — sent test message via {config.messenger_type}"
    except EnvironmentError as exc:
        return f"ERROR: {exc}"
    except ImportError as exc:
        return f"ERROR: {exc}"
    except Exception as exc:
        return f"ERROR: {exc}"


def _check_llm(config) -> str:
    """Run a trivial LLM completion to verify the provider works."""
    try:
        from .llm import get_llm_provider
        llm = get_llm_provider(config)
        reply = llm.complete("Say 'ok' and nothing else.")
        if reply and len(reply.strip()) > 0:
            return f"ok — {config.llm_provider} ({config.llm_model})"
        return f"ERROR: LLM returned empty response"
    except EnvironmentError as exc:
        return f"ERROR: {exc}"
    except Exception as exc:
        return f"ERROR: {exc}"


def main() -> None:
    args = sys.argv[1:]
    as_json = "--json" in args
    config_args = [a for a in args if not a.startswith("--")]

    if not config_args:
        print(
            "Usage: python -m researchclaw.init <config_path> [--json]",
            file=sys.stderr,
        )
        sys.exit(1)

    config_path = config_args[0]

    # ── Load config ──────────────────────────────────────────────────────────
    try:
        from .config import load_config
        config = load_config(config_path)
    except Exception as exc:
        result = {"success": False, "checks": {"config": f"ERROR: {exc}"}}
        if as_json:
            print(json.dumps(result, indent=2))
        else:
            print(f"[FAIL] config: {result['checks']['config']}")
        sys.exit(1)

    # ── Run checks ───────────────────────────────────────────────────────────
    checks: dict[str, str] = {}

    checks["config"] = f"ok — loaded from {config_path}"
    checks["directories"] = _check_directories(config.base_dir)
    # Ensure envs/ exists under project root (managed by EnvManager)
    project_root = Path(__file__).resolve().parent.parent
    envs_dir = project_root / "envs"
    envs_dir.mkdir(parents=True, exist_ok=True)
    checks["envs_directory"] = f"ok — {envs_dir}"
    checks["claude_settings"] = _write_claude_settings(config.base_dir)
    checks["git"] = _check_git()

    if config.llm_provider == "claude_cli":
        checks["claude_cli"] = _check_claude_cli(config.llm_claude_cli_path)
    else:
        checks["llm"] = _check_llm(config)

    checks["nvidia_smi"] = _check_nvidia_smi()
    checks["messenger"] = _check_messenger(config)

    # ── Summarise ────────────────────────────────────────────────────────────
    failed = [k for k, v in checks.items() if v.startswith("ERROR")]
    success = len(failed) == 0

    result = {"success": success, "checks": checks}

    if as_json:
        print(json.dumps(result, indent=2))
    else:
        width = max(len(k) for k in checks)
        for name, status in checks.items():
            icon = "✓" if not status.startswith("ERROR") else "✗"
            print(f"  {icon}  {name.ljust(width)}  {status}")
        print()
        if success:
            print("All checks passed.  Start the agent with:")
            print(f"  python -m researchclaw.agent {config_path}")
        else:
            print(f"Setup incomplete — {len(failed)} check(s) failed: {', '.join(failed)}")

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
